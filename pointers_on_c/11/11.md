### 动态内存分配
1. 为什么使用动态内存分配
	- 数组的长度常常在运行时确定
2. malloc和free（stdlib.h）
	- `void *malloc(size_t size);
		+ 从**可用内存池**中动态分配内存
		+ 未初始化
		+ size是需要的内存字节数，`size_t`是无符号数
		+ 连续的内存
		+ 可能稍微多一点（有编译器决定）
		+ 返回分配内存的起始指针`void *`,表示可以转换为其他任何类型的指针
		+ 如果可用内存无法满足，malloc会向操作系统请求更多内存，如果还无法满足，返回NULL指针
		+ 对于要求边界对齐的机器，malloc所返回的内存的起始位置将始终能够满足对边界对齐要就最严格的类型的要求
	- `void free(void *pointer);`
		+ free的参数必须要么是NULL，要么是一个先前从malloc、calloc或realloc返回的值
3. calloc和realloc
	- `void *calloc(size_t num_elements, size_t element_size);`
		+ 与malloc的区别是都初始化0
		+ 参数：*所需元素的数量*  *每个元素的字节数* 
	- `void realloc(void *ptr, size_t new_size);`
		+ 用于修改一个原先已经分配的内存块的大小
		+ 增加的内存为初始化，缩小的内存被拿掉
		+ 如果原先的内存块无法改变大小，realloc将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的块上
		+ realloc第一个参数是NULL时，就和malloc相同了
4. 常见的动态内存错误
	- **忘记检查所请求的内存是否成功分配**
	- **操作内存时超出了分配内存的边界**
	- 对NULL指针进行解引用操作
	- 释放并非动态分配的内存
	- 试图释放一块动态分配的内存的一部分
	- 一块动态内存被释放之后被继续使用
	- free释放一块内存的一部分是不允许的（可通过realloc函数缩小）
	- 程序中可能存在几份动态分配的内存指针的拷贝，在free内存之前，*确保这些拷贝在这块内存释放前停止使用。
	- **内存泄漏(memory leak)** : 分配内存但在使用完毕后不释放。 一个持续分配却一点不释放内存的程序最终将耗尽可用的内存。